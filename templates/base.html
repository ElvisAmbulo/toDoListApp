<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block tittle %}To do list{% endblock %}</title>

    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">

    <!-- Modal/alert-only styles (scoped to .messages and its children to avoid interfering) -->
    <style>
      /* Scope everything under .messages to avoid collisions */
      .messages {
        max-width: 680px;
        margin: 14px auto;
        position: relative;
        transition: opacity 260ms ease, transform 260ms ease;
        z-index: 9999; /* keep above normal content */
      }

      /* When container becomes empty hide it */
      .messages.hidden {
        opacity: 0;
        transform: scale(0.995);
        pointer-events: none;
        height: 0;
        overflow: hidden;
      }

      .messages .alert {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 12px;
        border-radius: 6px;
        color: #fff;
        margin: 10px 0;
        box-shadow: 0 6px 18px rgba(10,20,40,0.06);
        word-break: break-word;
        transition: opacity 360ms ease, transform 360ms ease, height 200ms ease, margin 200ms ease, padding 200ms ease;
        opacity: 1;
        transform: translateY(0);
      }

      /* Keep color variants small & simple */
      .messages .alert.success { background: linear-gradient(90deg,#2e9d4b,#2bb07a); }
      .messages .alert.danger  { background: linear-gradient(90deg,#d64545,#ff6b6b); }

      /* message text */
      .messages .alert .msg {
        flex: 1 1 auto;
        font-size: 14px;
        line-height: 1.3;
        padding-right: 8px;
      }

      /* close button */
      .messages .alert button.modalClose {
        background: transparent;
        border: 0;
        color: inherit;
        font-weight: 700;
        font-size: 20px;
        line-height: 1;
        cursor: pointer;
        padding: 0 6px;
        border-radius: 6px;
        transition: background 150ms ease;
      }
      .messages .alert button.modalClose:hover { background: rgba(255,255,255,0.08); }

      /* closing state (fade + slide up + collapse) */
      .messages .alert.closing {
        opacity: 0;
        transform: translateY(-10px) scale(0.995);
        margin-top: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
        height: 0 !important;
        overflow: hidden;
      }
    </style>
</head>
<body>
    <nav>
        <div class="logo">
            To do list
        </div>
        <input type="checkbox" name="nav-toggle" id="nav-toggle">

        <div class="navlinks">
            {% if session.user %}
            <a href="/">Home</a>
            <a href="/logout">Logout</a>
            {% else %}
            <a href="/register">Register</a>
            <a href="/login">Login</a>
            {% endif %}
        </div>

        <label for="nav-toggle" id="menu" class="toggler menu">&#9776;</label>
        <label for="nav-toggle" id="close" class="toggler close">&times;</label>
    </nav>

    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            <div class="messages" aria-live="polite" aria-atomic="false">
                {% for category, message in messages %}
                    {% if category == 'error' %}
                        <div class="alert danger">
                            <div class="msg">{{message}}</div>
                            <button class="modalClose" aria-label="Close alert">&times;</button>
                        </div>
                    {% else %}
                        <div class="alert success">
                            <div class="msg">{{message}}</div>
                            <button class="modalClose" aria-label="Close alert">&times;</button>
                        </div>
                    {% endif %}
                {% endfor %}
            </div>
        {% endif %}
    {% endwith%}

    <section>
        {% block contents %}{% endblock %}
    </section>

    <!-- Modal script only (manual close, auto-close after 5s, hide wrapper when empty) -->
    <script>
      (function () {
        const MESSAGES_SELECTOR = '.messages';
        const ALERT_SELECTOR = '.messages .alert';
        const CLOSE_BTN_SELECTOR = '.modalClose';
        const AUTO_CLOSE_MS = 5000;

        const messagesContainer = document.querySelector(MESSAGES_SELECTOR);
        if (!messagesContainer) return;

        // Helper to close an alert safely (idempotent)
        function closeAlert(alertEl) {
          if (!alertEl || alertEl.dataset.closing === 'true') return;
          alertEl.dataset.closing = 'true';
          alertEl.classList.add('closing');

          // Wait slightly longer than CSS to fully remove
          const removeAfter = 420;
          setTimeout(() => {
            if (alertEl.parentNode) alertEl.parentNode.removeChild(alertEl);
            hideMessagesIfEmpty();
          }, removeAfter);
        }

        function hideMessagesIfEmpty() {
          const remaining = messagesContainer.querySelectorAll('.alert');
          if (remaining.length === 0) {
            // animate container then hide
            requestAnimationFrame(() => {
              messagesContainer.classList.add('hidden');
            });
          }
        }

        function initAlerts() {
          const alerts = messagesContainer.querySelectorAll('.alert');
          alerts.forEach((alert) => {
            // avoid re-initializing
            if (alert.dataset.initialized === 'true') return;
            alert.dataset.initialized = 'true';

            // read per-alert custom duration if present (ms)
            const custom = parseInt(alert.getAttribute('data-autoclose'), 10);
            const duration = Number.isFinite(custom) ? custom : AUTO_CLOSE_MS;

            // create a timer that can be cleared on hover/click
            let timerId = setTimeout(() => closeAlert(alert), duration);

            // manual close
            const btn = alert.querySelector(CLOSE_BTN_SELECTOR);
            if (btn) {
              btn.addEventListener('click', (e) => {
                e.preventDefault();
                clearTimeout(timerId);
                closeAlert(alert);
              });
            }

            // optional: pause auto-close while hovering
            alert.addEventListener('mouseenter', () => {
              clearTimeout(timerId);
            });
            alert.addEventListener('mouseleave', () => {
              // restart a new timer only if not already closing
              if (alert.dataset.closing !== 'true') {
                timerId = setTimeout(() => closeAlert(alert), 1500); // give a short grace after mouse leaves
              }
            });
          });
        }

        // Observe additions to messages container (in case flashes are injected later)
        const observer = new MutationObserver((mutations) => {
          for (const m of mutations) {
            if (m.addedNodes && m.addedNodes.length) {
              // new alerts added: init them and ensure container visible
              initAlerts();
              messagesContainer.classList.remove('hidden');
            }
          }
        });
        observer.observe(messagesContainer, { childList: true });

        // Initial setup
        initAlerts();
        // If initially empty, hide container
        if (!messagesContainer.querySelector('.alert')) {
          messagesContainer.classList.add('hidden');
        }
      })();
    </script>
</body>
</html>
